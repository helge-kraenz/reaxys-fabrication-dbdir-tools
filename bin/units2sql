#! /usr/bin/env perl

=head1 NAME

units2sql - program converting the units table into SQL script.

=cut

# Modules and pragmas {{{
use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use Pod::Usage;
use Carp;
# Modules and pragmas }}}

# Global variables used in subroutines as well {{{
our $Version          = 1.0.0;
our $UpDown           = 0;
our $Separator        = "-" x 30;
our $UpTemplate       = "$Separator\n" . "-- UP   %6d ---------------\n" . "$Separator\n\n";
our $DownTemplate     = "$Separator\n" . "-- DOWN %6d ---------------\n" . "$Separator\n\n";
# Global variables used in subroutines as well }}}

# Command line variables {{{
my  $UnitsFile        = undef;
my  $SqlFile          = undef;
my  $Oracle           = undef;
my  $Man              = undef;
my  $Help             = undef;
my  $Style            = "Postgres";
my  $VersionParameter = undef;
# Command line variables }}}

# Command line parsing {{{

# Docs {{{

=head1 SYNOPSIS

units2sql [options]

 Options:
   -help            brief help message
   -man             full documentation
   -oracle          oracle style commands
   -sql <file>      specifies spez output file
   -units <file>    specifies units file
   -version         print version

=head1 OPTIONS

=over 4

=item B<-help>

Print a brief help message and exits.

=item B<-man>

Prints the manual page and exits.

=item B<-oracle>

Create Oracle style commands. If not set Postgres style is created.

=item B<-sql file>

The name of the output sql file. Required.

=item B<-units file>

The name of the input units file. Required.

=item B<-version>

Prints the version and exits.

=back

=cut

# Docs }}}

GetOptions( "help" => \$Help , "man" => \$Man , "oracle" => \$Oracle , "sql=s" => \$SqlFile , "units=s" => \$UnitsFile , "version" => \$VersionParameter );
# Command line parsing }}}

# Check command line parameters {{{
pod2usage( 1 ) if $Help;
pod2usage( -verbose => 2 ) if $Man;
pod2usage( "$0: No input units file given" ) if( ! $UnitsFile );
pod2usage( "$0: No output sql file given" ) if( ! $SqlFile );
$Style = "Oracle" if $Oracle;

if( $VersionParameter )
{
  ml( "This is $0, version $Version\n" );
  exit;
}
# Check command line parameters }}}

# Process DBDIR
processUnits( $UnitsFile , $SqlFile , $Style );

exit;

# processUnits {{{
sub processUnits
{
  my $File      = shift;
  my $SqlFile   = shift;
  my $Style     = shift;

  # Read and dump data {{{

  # Open input and output files
  my $Fi = undef;
  my $Fo = undef;
  open( $Fi , "<" , $File ) or confess "$File: $!\n";
  open( $Fo , ">" , $SqlFile ) or confess "$SqlFile: $!\n";

  my $Tab = "T_EINH";

  # Dump header lines {{{
  if( $Style =~ /oracle/i )
  {
    sql( $Fo , "truncate table $Tab;" );
  }
  elsif( $Style =~ /postgres/i )
  {
    sql( $Fo , "begin transaction;" ) if $Style =~ /postgres/i;
    sql( $Fo , "truncate table $Tab;" ) if $Style =~ /postgres/i;
  }
  else
  {
    confess "Illegal database style $Style\n";
  }
  # Dump header lines }}}

  # Dump payload {{{
  my $Section = "";
  while( <$Fi> )
  {
    chomp;
    if( /^\[/ )
    {
      ( $Section ) = m{\[(.*?)\]};
      next;
    }

    # Skip empty lines and lines not in section UNITS
    next if ! $_;
    next if( $Section ne "UNITS" );

    my @Cols = split( /\|/ );
    my $Cols = scalar @Cols;
    confess "Line $. file $File, is corrupt, expected 7 columns but found $Cols.\n" if $Cols != 7;

    # Standard escaping of apostrophe - as requires by SQL standard
    @Cols = map{ s{'}{''}g; $_ || "" } @Cols;

    # Oracle specific escaping
    if( $Style =~ /oracle/i )
    {
      @Cols = map{ s{&}{'||chr(38)||'}g; $_ } @Cols
    }
    for my $i (4..6)
    {
      $Cols[$i] = $Cols[$i] || "0";
    }

    my $Statement = sprintf( "INSERT INTO $Tab\n     VALUES ('%s','%s',%s,'%s',%s,%s,%s);\n" , @Cols);
    sql( $Fo , $Statement );
  }
  # Dump payload }}}

  # Dump footer lines {{{
  sql( $Fo , "commit;" );
  # Dump footer lines }}}

  # Close files
  close( $Fo );
  close( $Fi );

  # Read and dump data }}}

}
# processUnits }}}

# sql {{{
# Prints an SQL statement
sub sql
{
  my $Fo        = shift;
  my $Statement = shift;

  confess "Empty statement" if ! $Statement;
  $Statement = "$Statement\n" if $Statement !~ /\n$/;
  if( ! print $Fo $Statement )
  {
    confess "Cannot write to output file: $!\n";
  }
}
# sql }}}

# ml {{{
# Print log entry. Currently simply prints to stdout but this
# may change in future.
sub ml
{
  print shift;
}
# ml }}}

__END__

# Main docs {{{

=head1 DESCRIPTION

B<uinits2sql> reads a UNITS file as generated by B<ascii2dbdir> and converts this into
SQL statements creating the units table in the target database.

The program does not execute the SQL statements and consequently requires no database driver
and no database connection. Instead standard tools like SQLPlus (Oracle) and psql
(PostgreSQL) can be used to create the entries.

This program is pretty simple. It scans the input file for section UNITS.
Each line of this section which is not empty has to contain 7 columns separated by "|".
Those columns will be injected into the target table which is "T_EINH".

=head1 TESTS

This programm has been tested with RX data structure.

The generated output file is identical with those generated by Excel macro (*.ein)

=head1 EXAMPLES

The following command reas in units.tab and creates the files reaxys.ein.

$ units2sql.pl -sql reaxys.ein -unit units.tab

=cut

# Main docs }}}
